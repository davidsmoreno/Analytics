---
title: "Taller 2 MinerÃ­a de Datos"
author: "Manuel Sanchez y David Moreno"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: false
    theme: cosmo
    highlight: tango
---


### Universidad de los Andes MinerÃ­a de Datos â€“ MIIA 4200 

Se ha venido consolidando informaciÃ³n en los Ãºltimos aÃ±os sobre usuarios, en donde se incluye su nombre, apellido, edad, estrato social, entre otros. Sin embargo, en muchas oportunidades no se cuenta con informaciÃ³n completa sobre algunas variables no crÃ­ticas
como podrÃ­a ser el gÃ©nero de la persona.

Considere que usted tiene una tarea de clasificar como â€œMasculinoâ€ o â€œFemeninoâ€ una lista de personas solo contemplando su primer nombre. Por ejemplo, se asocia a MarÃ­a con un gÃ©nero Femenino y Ricardo con un gÃ©nero Masculino. Este ejercicio es sencillo y se basa un poco en la experiencia que se tiene del analista, pero Â¿quÃ© pasa si tiene que repetir este ejercicio de manera continua y con una gran cantidad de registros? En ese caso se complica un poco ese proceso de clasificaciÃ³n y se requieren de herramientas de MinerÃ­a de Datos.

Para su alivio se cuenta con informaciÃ³n que puede llegar a ser bastante Ãºtil en R-Project:
*â€¢* Se cuenta con el paquete genero, el cual tiene una base de 9810 nombres en espaÃ±ol usando el comando names_gender_es
*â€¢* Hay algunas herramientas que se pueden usar para extraer informaciÃ³n como:

- ğ‘ ğ‘¡ğ‘Ÿğ‘ ğ‘ğ‘™ğ‘–ğ‘¡("ğ‘ğ‘ğ‘","") la cual genera una lista con cada una de las palabras del texto seleccionado (â€œaâ€, â€œbâ€, â€œcâ€)
- ğ‘™ğ‘’ğ‘¡ğ‘¡ğ‘’ğ‘Ÿğ‘  y ğ¿ğ¸ğ‘‡ğ‘‡ğ¸ğ‘…ğ‘† contiene una lista de letras en minÃºscula o mayÃºscula del alfabeto en espaÃ±ol
- ğ‘›ğ‘â„ğ‘ğ‘Ÿ(ğ‘¥) permite conocer la longitud de un texto
- ğ‘ ğ‘¢ğ‘ğ‘ ğ‘¡ğ‘Ÿ("ğ‘€ğ‘–ğ‘›ğ‘’ğ‘ŸÃ­ğ‘", 1, 2) extraer los primeros dos caracteres (â€œMiâ€)
- ğ‘ ğ‘¢ğ‘ğ‘ ğ‘¡ğ‘Ÿ("ğ‘€ğ‘–ğ‘›ğ‘’ğ‘Ÿğ‘–ğ‘", ğ‘›ğ‘â„ğ‘ğ‘Ÿ("ğ‘€ğ‘–ğ‘›ğ‘’ğ‘Ÿğ‘–ğ‘") âˆ’ ğ‘ğ‘¢ğ‘š + 1, ğ‘›ğ‘â„ğ‘ğ‘Ÿ("ğ‘€ğ‘–ğ‘›ğ‘’ğ‘Ÿğ‘–ğ‘")) para extraer ğ‘ğ‘¢ğ‘š caracteres de un texto
- ğ‘¥[! ğ‘–ğ‘ . ğ‘›ğ‘(ğ‘¥)] permite eliminar los NA de mi vector ğ‘¥

Tomando en cuenta lo anterior, se le pide que contemple un problema de clasificaciÃ³n usando como muestra de entrenamiento el 90% de la base de names_gender_es y el resto como muestra de prueba. Para ello, se le pide que considere que use un problema de
K-vecinos mÃ¡s cercanos usando la funciÃ³n knn de R.




```{r setup, include=FALSE}

library(genero)
data("names_gender_es")
attach(names_gender_es)
library(tidyverse)
library(stringi)
head(names_gender_es)
```

### Limpieza y creaciÃ³n de las variables

Primero notamos que hay algunos strings que que no representan la informaciÃ³n, por ejemplo vemos a un string como \\u00f que posiblemente se debe que el archivo tiene una codificacion de tipo UNICODE, por lo se buscara una funcion que nos ayudara a la trasnformacion de este para que los datos sera lo mas legibles posibles y se entienda completamente la naturaleza del nombre. Por lo que el plan de accion es el siguiente:

A. Se realiza una limpieza del dato nombre para poder capturar de la mejor manera las caracteristicas del mismo.
B. Se crearan columnas, cada una representando alguna caracteristica del string, que pueda servinor a diferencia si es hombre o si es mujer. variables en donde se pueda extraer informacion del nombre y que pueda resultar relevantes para predecir el sexo
C. Con la nuevas variables creadas procedemos a crear una muestra test y de entrenamiento para realizar el algoritmo de k-vecinos con el fin de clasificarlos y poder tener un medida de precision de este algoritmo al predecir la muestra test.

El siguiente codigo: hace la limpieza y creacion de la nuevas variables

```{r }
Nombres <- names_gender_es %>%
  mutate(
    Longitud = nchar(stri_unescape_unicode(name)),
    Cuenta_A = stri_count_fixed(stri_trans_tolower(stri_unescape_unicode(name)), "a"),
    Cuenta_Vocales = stri_count_regex(stri_trans_tolower(stri_unescape_unicode(name)), "[aeiou]"),
    Num_Consonantes = stri_count_regex(stri_trans_tolower(stri_unescape_unicode(name)), "[bcdfghjklmnpqrstvwxyz]"),
    Terminacion = as.factor(case_when(
      stri_sub(stri_unescape_unicode(name), -1, -1) %in% c("a", "y") ~ 1,
      stri_sub(stri_unescape_unicode(name), -1, -1) %in% c("o") ~ 2,
      TRUE ~ 3)
    ),
    Tiene_Acentos_Principales = ifelse(str_detect(stri_unescape_unicode(name), "[Ã¡Ã©Ã­Ã³ÃºÃ¼Ã±]"), 1, 0)
  )


```

Las variables que se han definido capturan diferentes aspectos de los nombres que son relevantes para nuestra clasificaciÃ³n. Por ejemplo, la variable "Longitud" simplemente cuenta la cantidad de letras en un nombre, "Cuenta_A" y "Cuenta_Vocales" se centran en conteos especÃ­ficos dentro del nombre: la primera cuenta la cantidad de letras "a" presentes, mientras que la segunda cuenta el nÃºmero total de vocales. "Num_Consonantes" ofrece un complemento a esta informaciÃ³n al contar la cantidad de consonantes en el nombre. La variable "Terminacion" es una caracterÃ­stica categÃ³rica que clasifica los nombres segÃºn su Ãºltima letra, asignando diferentes valores segÃºn si terminan en "A" o "Y", en "O", o en cualquier otro carÃ¡cter. Por Ãºltimo, "Tiene_Acentos_Principales" detecta la presencia de acentos principales, como tildes o diÃ©resis.



### Variables


1. Longitud: Cantidad de letras del nombre
2. Cuenta_A: Cantidad de "a" del nombre
3. Cuenta_Vocales: Cantidad de vocales del nombre
4. Num_Consonantes: Cantidad de consonantes del nombre
5. Terminacion: Es una variables de 3 categorias: 1 si termina en A-Y, 2 si termina O y 3 en otro caso.
6. Tiene_Acentos_Principales: Es una variable que detecta si el nombre posee algun acento como tilde, diericis.


### Test y Entrenamiento division

Con el paso de limpieza y construccion de variables concluidos, procedemos a nuestra nueva base, construir la muestra de entrenamiento sera la cual se realizara el algoritmo de K-vecinos y la muestra test la cual mediremos la precision de este, para ellos se coloca una semilla para replicar los resultados.

```{r}
set.seed(123) # Semilla 

# Dividir el conjunto de datos en conjuntos de entrenamiento y prueba
indices_entrenamiento <- sample(1:nrow(Nombres), 0.9 * nrow(Nombres))  # 90% para entrenamiento
datos_entrenamiento <- Nombres[indices_entrenamiento, ]
datos_prueba <- Nombres[-indices_entrenamiento, ]

```

### Modelado y EvaluaciÃ³n

A continuacion seleccionaremos las variables predictoras para la clasificacion de los nombres en Masculino o Femenino despues de realizar el algoritmo, se procede a calcular la precision del modelo y asi mismo construir la matriz de confunsion para detectar cuales son los principales problemas de este metodo de clasificacion.

```{r}

library(class) # Carga la librerÃ­a para KNN

features <- c("Longitud", "Cuenta_A", "Cuenta_Vocales", "Num_Consonantes", "Terminacion","Tiene_Acentos_Principales")
target <- "gender"  

# Entrenar el modelo KNN
modelo_knn <- knn(train = datos_entrenamiento[, features], 
                  test = datos_prueba[, features], 
                  cl = datos_entrenamiento[[target]], 
                  k = 5)  

# Evaluar el modelo
precision <- sum(modelo_knn == datos_prueba[[target]]) / nrow(datos_prueba)
cat("PrecisiÃ³n del modelo KNN:", precision, "\n")

# Matriz de confusiÃ³n para una evaluaciÃ³n detallada
conf_matrix <- table(Real = datos_prueba[[target]], Prediccion = modelo_knn)
print(conf_matrix)

``` 
La precisiÃ³n del modelo es de aproximadamente un 78%, lo que significa que el algoritmo de k-vecinos coincide en 78 de cada 100 casos con los resultados reales, lo cual es bastante bueno.

La matriz de confusiÃ³n revela que el modelo muestra una mayor precisiÃ³n al predecir nombres masculinos, con 467 aciertos y 62 equivocaciones al clasificar hombres como mujeres. Sin embargo, presenta un desempeÃ±o menos preciso al predecir nombres femeninos, con 302 predicciones correctas frente a 150 errores, donde nombres de mujeres fueron confundidos con los de hombres. Esta disparidad en el rendimiento podrÃ­a atribuirse a algunas caracterÃ­sticas capturadas que no logran diferenciar claramente entre los sexos. Sin embargo para solo tener el primer nombre de un nombre, produce resultados bastante buenos.